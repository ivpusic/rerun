package main

import (
	"os"
	"path/filepath"
	"strings"
	"time"

	"gopkg.in/fsnotify.v1"
)

type watcher struct {
	pm    *processManager
	queue chan fsnotify.Event
	exit  chan bool
}

// if we got relevant file event, and file extension is supported, and we didn't ignore changed file
// then we can confirm this file is important for us, and we should do required actions on it
func (w *watcher) isEventImportant(ev fsnotify.Event) bool {
	file := ev.Name

	// if change file is actually build file, than skip it
	if strings.HasSuffix(file, w.pm.conf.build) {
		return false
	}

	importantEvent := ev.Op == fsnotify.Write || ev.Op == fsnotify.Rename || ev.Op == fsnotify.Remove || (w.pm.conf.Attrib && ev.Op == fsnotify.Chmod)
	if !importantEvent {
		return false
	}

	supportedFile := false
	for _, suffix := range w.pm.conf.Suffixes {
		if strings.HasSuffix(file, suffix) {
			supportedFile = true
			break
		}
	}

	if !supportedFile {
		logger.Debugf("File %s changed but file extension is not enabled, so skip it!", file)
		return false
	}

	abs, err := filepath.Abs(file)
	if err != nil {
		logger.Errorf("Error while converting file %s to absolute path! %s", file, err.Error())
		return false
	}

	if contains(w.pm.conf.Ignore, abs) {
		logger.Debugf("File %s changed but it is in ignore list, so skip it!", file)
		return false
	}

	// if we got rename event, but file exist, we should ignore event
	if ev.Op == fsnotify.Rename {
		if _, err := os.Stat(file); err == nil {
			return false
		}
	}

	return true
}

// we get many events when file changes,
// so wait a little bit to wait for clear situation
func (w *watcher) throttleEvents() {
	time.Sleep(50 * time.Millisecond)

	for {
		select {
		case <-w.queue:
		default:
			return
		}
	}
}

// if event is relevant, reload app
func (w *watcher) processFileEvents() {
	for {
		select {
		case ev, ok := <-w.queue:
			if !ok {
				return
			} else {
				if w.isEventImportant(ev) {
					w.throttleEvents()

					logger.Debugf("reloading due to change in file: %s", ev.Name)
					logger.Info("change detected, reloading...")
					w.pm.stop()
					w.pm.run()
				}
			}
		}
	}
}

// start watching changes on files
func (w *watcher) start() {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		logger.Panicf("Error while trying to watch files! %s", err.Error())
	}

	defer watcher.Close()
	w.exit = make(chan bool)
	w.queue = make(chan fsnotify.Event, 100)

	go w.processFileEvents()
	go func() {
		for {
			select {
			case ev := <-watcher.Events:
				w.queue <- ev
			case err := <-watcher.Errors:
				logger.Errorf("error generated by watcher: %q", err.Error())
				w.exit <- true
			}
		}
	}()

	root, err := filepath.Abs(".")
	if err != nil {
		logger.Panicf("Error while looking for absolute application path! %s", err.Error())
	}

	err = filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if contains(w.pm.conf.Ignore, path) {
			logger.Debugf("Ignoring %s\n", path)
			if info.IsDir() {
				return filepath.SkipDir
			}
			return nil
		}
		if info.IsDir() {
			return watcher.Add(path)
		}

		return nil
	})

	if err != nil {
		logger.Panicf("Error while reading list of files to listen! %s", err.Error())
	}

	w.pm.run()
	logger.Info("rerun started. watching for changes...")

	<-w.exit
}
